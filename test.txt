
Je fais des test dans Bash pour ;ieux comprendre le fonction des exit ou cd dans certains type de comportements


________________________________________________________________________________
PIPE ET EXECUTON DE CD
________________________________________________________________________________

cd New_doc | ls -a

ls -a (sur le documents courant dans lequel je me trouve)
Je n ai pas changer de position


ls -a | cd New_doc

Ne fais pas de ls -a (ligne vide)

________________________________________________________________________________

PIPE ET EXECUTION D EXIT
________________________________________________________________________________

exit | ls -a

fais un ls -a sur le repertoire courant

ls -a | exit

Fais rien ligne vide

On va donc partir d un principe de base
On fork() uniqument quand on pipe 

Si il n y a pas de pipe ill n y a donc as de processus "enfant" et les 
fonctions cd et exit s execute alors sur le processus parent

Neamoins les fonction exec_other nessecite obligatoirement un processus enfant 
fork() pour pouvoir s executer

________________________________________________________________________________

Plus complique que ca

Par default bool fork toujour egale a 1 // Pourquoi l utilite de cette variable

a NOTER QUE DANS LA FONCTION 
exit_built toujours effectuer avant de fermer le pipe 

// if(cmds->is_piped)
//		close(cmds->pipes[0]);
// Et relance execve
//     Mais pas tres propres parce que relance ls et autre commandes 
		au niveau des built in

________________________________________________________________________________

DONE


________________________________________________________________________________


J ai legerement regarder comment fonctionner les assignations par curiosite

grosso modo l assignations se fait uniquement si uniquement des assignations

Si assignations et commandes la commandes s effectue et les assignations qui
la suivent sont consideres commes des tokens 


________________________________________________________________________________




Grosso modo On met la fonction 
_____________________________________________________

setup_signals || handle_signals(void)

au debut du main

if(!setup_signals())
	return(nice_errors(0, NULL))
-----------------------------------

setup_signal

Fin wait_exec(Sans protections);

_____________________________________________________

disable_signals || inhibit_signals(int id)

apres le fork();
ou avant l execution
_____________________________________________________

Ctrl C

recoit un SIGINT au processus courant (terminer l application)

Ctrl \

Comme Ctrl C

Ctrl D

dit au terminal un EOF sur l entree standard qui est interprete comme un 
desire de sortir

________________________________________________________________________________

Grosso modo d apres la fonction disable_signals

Si la est fork(cmds->pid)

ou
                cmds->pid == 0

	On met le signal (SIGQUIT, SIG_DFL < 0)
						return(0);
					(SIGINT, SIG_DFL) < 0
	Sinon
				cmds->pid != 0 (Processus parent)
			le signal((SIGQUIT, ignore) < 0)
					return(0);
			le signal((SIGINT, ignore) < 0)
					return(0);

set_up signals

Attends que tous les processus fils soit effectuer

puis

remet (SIGQUIT, ctrl_slash)
      (SIGINT, ctrl_C)

________________________________________________________________________________
